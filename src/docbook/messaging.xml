<?xml version="1.0" encoding="UTF-8"?>
<chapter id="messaging">
  <title>Messaging</title>

  <para>In the previous chapter the basic test case structure was introduced with <emphasis>variables</emphasis> and
  <emphasis>test actions</emphasis>. The &lt;actions&gt; element contains a list of actions that take place during the test case. 
  Each test action is executed in sequential order. Citrus offers several built-in test actions that the user can choose from to construct a complex
  test workflow. The available test actions are discussed in the next sections.</para>
  
  <para>As sending and receiving messages is essential in integration testing of message-based architectures we will handle these actions in first place.
  But first of all lets have a look at the common message interface in Citrus:</para>
  
  <mediaobject>
    <imageobject role="fo">
      <imagedata align="center" display="block" fileref="images/figure_001.png" format="PNG" />
    </imageobject>
    
    <imageobject role="html">
      <imagedata align="center" display="block" fileref="images/figure_001.png" format="PNG" />
    </imageobject>
  </mediaobject>
  
  <para>A message consists of a message header (name-value pairs) and a message payload. Later in this document we will see how 
  a test constructs several messages with payload and header values. But first of all let's concentrate on sending and receiving 
  messages to/from various transports. MesageSender and MessageReceiver components play a significant role in this respect. The next figure shows a 
  typical MessageSender component in Citrus:</para>
  
  <mediaobject>
    <imageobject role="fo">
      <imagedata align="center" display="block" fileref="images/figure_002.png" format="PNG" />
    </imageobject>
    
    <imageobject role="html">
      <imagedata align="center" display="block" fileref="images/figure_002.png" format="PNG" />
    </imageobject>
  </mediaobject>

  <para>The MessageSender publishes messages to a destination. This destination can be a JMS queue/topic, a SOAP WebService endpoint, a Http URL 
  and many more. The MessageSender just takes a previously defined message and sends it to the message destination.</para>
  
  <para>Similar to that Citrus defines the MessageReceiver component to consume messages from destinations. This can be a simple subscription
  on message channels and queues/topics. In case of SOAP WebServices and Http GET/POST things are more complicated as we have to provide a 
  server component in combination with a MessageReceiver. We will handle this server related communication later in this document. For now
  a MessageReceiver component is defined like this:</para>
  
  <mediaobject>
    <imageobject role="fo">
      <imagedata align="center" display="block" fileref="images/figure_003.png" format="PNG" />
    </imageobject>
    
    <imageobject role="html">
      <imagedata align="center" display="block" fileref="images/figure_003.png" format="PNG" />
    </imageobject>
  </mediaobject>
  
  <para>In the next sections you learn how a test case uses those MessageSenders and MessageReceivers for publishing and consuming 
  messages.</para>
  
  <section id="message-sending">
    <title>Sending messages</title>

    <para>The &lt;send&gt; action publishes messages to a destination. The transport that is used does - for now - not
    matter to the test case. The test case simply defines the message contents and uses a predefined message sender to actually 
    publish the constructed message. There are several message sender implementations in Citrus available representing different transport protocols like JMS, SOAP, 
    HTTP, TCP/IP and many more.</para>
     
    <para>Again the type of transport is not specified in the test case directly, but in the message sender definitions. The separation of concerns (test case/message sender transport) 
    gives us a good flexibility of our test cases. The test case does not know anything about connection factories, queue names or endpoint urls. The transport underneath a 
    sending action can change easily without affecting the test case definition. We will see later in this document how to create different message senders for various transports 
    in Citrus. For now we concentrate on constructing the message content to be sent.</para>
    
    <para>We assume that the message's payload will be plain XML format. Citrus supports XML payloads as default payload format. Citrus is not limited to XML message format 
    though; you can always add message converters and marshallers. But to be honest XML is a very popular message format in Enterprise Applications and messaging solutions. I do not 
    see the point why you should not use XML unless you deal with legacy interfaces or strongly need to avoid the XML message overhead. Anyway Citrus works best on XML payloads 
    and you will see a lot of example code in this document using XML. Finally let us have a look at a first example how a sending action is defined in the test.</para>
    
    <programlisting>
  &lt;testcase name=&quot;sendMessageTest&quot;&gt;
      &lt;description&gt;
          Send message example
      &lt;/description&gt;
      &lt;variables&gt;
          &lt;variable name=&quot;requestTag&quot; value=&quot;Rx123456789&quot;/&gt;
          &lt;variable name=&quot;correlationId&quot; value=&quot;Cx1x123456789&quot;/&gt;
      &lt;/variables&gt;
      &lt;actions&gt;
          &lt;send with=&quot;getCustomerRequestMessageSender&quot;&gt;
              &lt;message&gt;
                  &lt;data&gt;
                      &lt;![CDATA[
                      &lt;RequestMessage&gt;
                          &lt;MessageHeader&gt;
                              &lt;CorrelationId&gt;${correlationId}&lt;/CorrelationId&gt;
                              &lt;Timestamp&gt;2001-12-17T09:30:47.0Z&lt;/Timestamp&gt;
                              &lt;RequestTag&gt;_&lt;/RequestTag&gt;
                              &lt;VersionId&gt;2&lt;/VersionId&gt;
                          &lt;/MessageHeader&gt;
                          &lt;MessageBody&gt;
                              &lt;Customer&gt;
                                  &lt;Id&gt;1&lt;/Id&gt;
                              &lt;/Customer&gt;
                          &lt;/MessageBody&gt;
                      &lt;/RequestMessage&gt;
                      ]]&gt;
                  &lt;/data&gt;
                  &lt;element path=&quot;/MessageHeader/RequestTag&quot; 
                              value=&quot;${requestTag}&quot;/&gt;
              &lt;/message&gt;
              &lt;header&gt;
                  &lt;element name=&quot;Operation&quot; value=&quot;GetCustomer&quot;/&gt;
                  &lt;element name=&quot;RequestTag&quot; value=&quot;${requestTag}&quot;/&gt;
              &lt;/header&gt;
          &lt;/send&gt;
      &lt;/actions&gt;
  &lt;/testcase&gt;
    </programlisting>
    
    <para>The test uses two variable definitions (<emphasis>requestTag</emphasis> and <emphasis>correlationId</emphasis>), 
    so first of all let us refresh in mind what variables do. Test variables are defined at the very beginning of the test case and 
    are valid throughout all actions that take place in the test. This means that actions can simply reference a variable by the 
    expression <literal>${variable-name}</literal>.</para> 
    
    <tip>
        <para>Use variables wherever you can! At least the important entities of a test should be defined as variables at the 
        beginning. The test case improves maintainability and flexibility when using variables.</para>
    </tip>
    
    <para>Now lets have a closer look at the sending action. The 'with' attribute might catch someone's attention in first place. 
    So what does the 'with' attribute do? This attribute references a message sender definition by name. As previously mentioned the 
    message sender definition lies in a separate configuration file and contains the actual message transport configurations. In this example the 
    <emphasis>&quot;getCustomerRequestMessageSender&quot;</emphasis> is used to send the message over JMS to a destination queue. 
    The test case is not aware of these transport details, because it does not have to. The advantages are obvious: On the one hand many test 
    cases may reuse a single message sender definition in order to send messages of type 'getCustomerRequest'. Secondly test cases are independent of
    message transport details. Connection factories, user credentials, endpoint urls are not present in the test cases but are configured in a central
    place - the actual message sender configuration.</para>
    
    <para>In other words the attribute &quot;with&quot; in the &lt;send&gt; element specifies which message sender definition 
    to use for sending the message. Once again all available message senders are configured in a separate Spring configuration file. 
    We will come to this later. Be sure to always pick the right message sender type in order to publish your message to the right 
    destination endpoint.</para>
    
    <tip>
        <para>It is good practice to follow a naming convention when choosing names for message senders and receivers. The intended
        purpose of the message sender as well as the sending/receiving actor should be clear when choosing the name. For instance messageSender1,
        messageSender2 will not give you much hints to the purpose of the message sender.</para>
    </tip>
    
    <para>Now that the used message sender is clear, we finally can specify the message content to be sent. 
    The message content is declared with these elements:</para>
        
    <itemizedlist mark="opencircle">
        <listitem>
            <para><emphasis>message</emphasis>: This element constructs the message to be sent. There are several child elements available:</para>
            <itemizedlist mark="opencircle">
                <listitem>
                    <para><emphasis>data</emphasis>: Inline CDATA definition of the message payload (instead of &lt;resource&gt; element)</para>                
                </listitem>
                <listitem>
                    <para><emphasis>resource</emphasis>: External file resource holding the message payload (instead of &lt;data&gt; element)</para>
                    <para>The syntax would be: &lt;resource file="file:xmlData/NumberDeallocationRequest.xml" /&gt;</para>
                    <para>The file path prefix indicates the resource type, so the file location is resolved either as file system resource (file:) 
                    or classpath resource (classpath:).</para>
                </listitem>
                <listitem>
                    <para><emphasis>element</emphasis>: Explicitly overwrite values in the XML message payload using XPath. You can replace message content 
                    with dynamic values before sending. Each &lt;element&gt; entry provides a &quot;path&quot; and &quot;value&quot; attribute. The &quot;path&quot; 
                    gives a XPath expression evaluating to a XML node element or attribute in the message. The &quot;value&quot; can be a variable expression or any other 
                    static value. Citrus will replace the value before sending the message.</para>
                </listitem>
            </itemizedlist>
        </listitem>
        <listitem>
            <para><emphasis>header</emphasis>: Defines a header for the message (e.g. JMS header information or SOAP header):</para>
            <itemizedlist mark="opencircle">
                <listitem>
                    <para><emphasis>element</emphasis>: Each header receives a &quot;name&quot; and &quot;value&quot;. The &quot;name&quot; will be the 
                    name of the header entry and &quot;value&quot; its respective value. Again the usage of variable expressions as value is supported here, too.</para>
                </listitem>
            </itemizedlist>
        </listitem>
    </itemizedlist>
    
    <para>The most important thing when dealing with sending actions is to prepare the message payload and header. You are able to construct the message payload either by 
    inline CDATA (&lt;data&gt;) or external file (&lt;resource&gt;). Before sending takes place you can explicitly replace some message values. You can think of overwriting
    specific message elements with variable values for instance. The example above uses the variable ${correlationId} directly in the XML payload definition. In addition to 
    that you can use XPath expressions for overwriting message contents before sending. The &quot;/MessageHeader/RequestTag&quot; XPath expression for instance overwrites 
    the respective request tag value in the message. The two approaches of overwriting message elements before sending can coexist simultaneously.</para>
     
    <para>The message header is manipulated too. So Citrus uses name-value pairs like &quot;Operation&quot; and &quot;RequestTag&quot; in the example above to
    set the message's header entries.</para>
    
    <para>This is how you send messages in Citrus. The test case is responsible for constructing the message content while predefined message senders are reused to publish 
    the messages. The variable support in message payload and message header enables you to add dynamic values.</para>
  </section>
  
  <section id="message-receiving">
    <title>Receiving messages</title>

    <para>Now after sending a message with Citrus we would like to receive a message inside the test. 
    Let us again have a look at a simple example showing how it works.</para>
    
    <programlisting>
  &lt;receive with=&quot;getCustomerResponseReceiver&quot;&gt;
      &lt;selector&gt;
          &lt;value&gt;operation = 'GetCustomer'&lt;/value&gt;
      &lt;/selector&gt;
      &lt;message&gt;
          &lt;data&gt;
              &lt;![CDATA[
              &lt;RequestMessage&gt;
                  &lt;MessageHeader&gt;
                      &lt;CorrelationId&gt;${correlationId}&lt;/CorrelationId&gt;
                      &lt;Timestamp&gt;2001-12-17T09:30:47.0Z&lt;/Timestamp&gt;
                      &lt;RequestTag&gt;_&lt;/RequestTag&gt;
                      &lt;VersionId&gt;2&lt;/VersionId&gt;
                  &lt;/MessageHeader&gt;
                  &lt;MessageBody&gt;
                      &lt;Customer&gt;
                          &lt;Id&gt;1&lt;/Id&gt;
                      &lt;/Customer&gt;
                  &lt;/MessageBody&gt;
              &lt;/RequestMessage&gt;
              ]]&gt;
          &lt;/data&gt;
          &lt;element path=&quot;//MessageHeader/RequestTag&quot; 
                      value=&quot;${requestTag}&quot;/&gt;
      &lt;/message&gt;
      &lt;header&gt;
          &lt;element name=&quot;Operation&quot; value=&quot;GetCustomer&quot;/&gt;
          &lt;element name=&quot;RequestTag&quot; value=&quot;${requestTag}&quot;/&gt;
      &lt;/header&gt;
      &lt;extract&gt;
          &lt;header name=&quot;Operation&quot; variable=&quot;${operation}&quot;/&gt;
          &lt;message path=&quot;//MessageBody/Customer/Id&quot; 
                      variable=&quot;${customerId}&quot;/&gt;
      &lt;/extract&gt;
  &lt;/receive&gt;
    </programlisting>
    
    <para>Knowing the send action of the previous chapter we can identify some common mechanisms that apply for both 
    sending and receiving actions. This time the test uses a predefined message receiver in order to receive the message 
    over a certain transport. Again the test is not aware of the transport details (e.g. JMS connection factory, 
    queue names, etc.) but the message receiver does know this information.</para>
    
    <para>While the action tries to receive a message the whole test execution will be delayed. This is
    important to ensure the step by step test workflow processing. The receiver will only wait a given amount of time for
    the message to arrive. A timeout exception fails the test in case the message does not arrive in time.</para>
    
    <para>Once the message has arrived, the content can be validated in various ways. On the one hand you
    can specify a whole XML message template that you expect. In this case the received XML structure will
    be compared to the expected XML message element by element. On the other hand you can use explicit element validation where only a 
    small subset of message elements is included into validation.</para>
    
    <para>Besides this message payload validation the framework can also validate the message header values where variable usage is 
    supported as usual during the whole validation process.</para>
    
    <para>In general the validation component (validator) in Citrus works hand in hand with a message reveiving component as the following
    figure shows:</para>
    
    <mediaobject>
      <imageobject role="fo">
        <imagedata align="center" display="block" fileref="images/figure_005.png" format="PNG" />
      </imageobject>
      
      <imageobject role="html">
        <imagedata align="center" display="block" fileref="images/figure_005.png" format="PNG" />
      </imageobject>
    </mediaobject>
   
    <para>The message receiving component passes the message to the validator where the validation steps take place. Let us have a closer 
    look at the validation options and features step by step.</para>
    
    <section id="message-payload-validation">
        <title>Validate message content</title>
        
        <para>Once Citrus has received a message the tester can validate the message contents in various ways. First of all the tester can compare 
        the whole message payload to a predefined control message template.</para>
        
        <para>The receiving action offers following elements for control message templates:</para>
        <itemizedlist mark="opencircle">
            <listitem>
                <para><emphasis>&lt;data&gt;</emphasis>: Defines an inline XML message template as nested CDATA</para>
            </listitem>
            <listitem>
                <para><emphasis>&lt;resource&gt;</emphasis>: Defines an expected XML message template via external file resources</para>
            </listitem>
        </itemizedlist>
        
        <para>Both ways inline CDATA XML or external file resource give us a control message template. Citrus uses this
        control template for extended XML tree comparison. All elements, namespaces, attributes and node values are validated in XML DOM tree comparison.
        Only in case received message and control message are equal to each other the message validation will succeed. In case differences occur Citrus gives
        detailed error messages and the test fails.</para>
        
        <para>Now up to now the control message template is very static. Message comparison in this high extend has to be much more robust. This is why Citrus supports
        various ways to add dynamic message content and ignored elements to the XML tree validation. The tester can enrich the expected message template with test variables 
        or some elements can be completely ignored in validation.</para>
    </section>
    
    <section id="message-dynamic-validation">
        <title>Dynamic message values</title>
        
        <para>Some elements in our message payload might be of variable nature. Just think of identifiers that should not be static in our expected message template.
        Instead of repeating the ids several times hardcoded in our test we overwrite those elements with variable values. This can be done with XPath or inline variable
        declarations. Lets have a look at a example listing showing both ways to overwrite message tempalte content before validation:</para>
        
        <programlisting>
  &lt;message&gt;
      &lt;data&gt;
          &lt;![CDATA[
          &lt;RequestMessage&gt;
              &lt;MessageHeader&gt;
                  &lt;CorrelationId&gt;${correlationId}&lt;/CorrelationId&gt;
                  &lt;Timestamp&gt;2001-12-17T09:30:47.0Z&lt;/Timestamp&gt;
                  &lt;RequestTag&gt;_&lt;/RequestTag&gt;
                  &lt;VersionId&gt;2&lt;/VersionId&gt;
              &lt;/MessageHeader&gt;
              &lt;MessageBody&gt;
                  &lt;Customer&gt;
                      &lt;Id&gt;1&lt;/Id&gt;
                  &lt;/Customer&gt;
              &lt;/MessageBody&gt;
          &lt;/RequestMessage&gt;
          ]]&gt;
      &lt;/data&gt;
      &lt;element path=&quot;//MessageHeader/RequestTag&quot; 
                  value=&quot;${requestTag}&quot;/&gt;
  &lt;/message&gt;
        </programlisting>
        
        <para>The program linsting shows both ways of setting variable values inside a message template. First of all you can
        simply place variable expressions inside the message (see how ${correlationId} is used). Secondly you can also use 
        XPath expressions to explicitly overwrite message elements before validation.</para>
        
        <para><literal>&lt;element path=&quot;//MessageHeader/RequestTag&quot; value=&quot;${requestTag}&quot;/&gt;</literal></para>
        
        <para>The XPath expression evaluates to the message template, searches for the right element and replaces the element value. Of course 
        this works with attributes too.</para>
        
        <para>Both ways via XPath or inline variable expressions are equally to each other. Choose one way that fits best for you. This is how we can add dynamic variable
        values to the control template in order to increase maintainability and robustness of message validation.</para>
        
    </section>
    
    <section id="message-validation-ignore">
        <title>Ignore message elements</title>
        
        <para>Some elements in the message payload might not apply for validation at all. Just think of communication timestamps an dynamic values inside a 
        message:</para>
        
        <programlisting>
  [...]
      &lt;Timestamp&gt;2001-12-17T09:30:47.0Z&lt;/Timestamp&gt;
  [...]
        </programlisting>
        
        <para>The timestamp value will dynamically change from test run to test run and is hardly predictable for the tester, so lets ignore it in validation.</para>
        
        <programlisting>
   &lt;message&gt;
      &lt;data&gt;
          &lt;![CDATA[
          &lt;RequestMessage&gt;
              &lt;MessageHeader&gt;
                  &lt;CorrelationId&gt;${correlationId}&lt;/CorrelationId&gt;
                  &lt;Timestamp&gt;@ignore@&lt;/Timestamp&gt;
                  &lt;RequestTag&gt;${requestTag}&lt;/RequestTag&gt;
                  &lt;VersionId&gt;2&lt;/VersionId&gt;
              &lt;/MessageHeader&gt;
              &lt;MessageBody&gt;
                  &lt;Customer&gt;
                      &lt;Id&gt;1&lt;/Id&gt;
                  &lt;/Customer&gt;
              &lt;/MessageBody&gt;
          &lt;/RequestMessage&gt;
          ]]&gt;
      &lt;/data&gt;
      &lt;ignore path=&quot;//ResponseMessage/MessageHeader/Timestamp&quot;/&gt;
  &lt;/message&gt;     
        </programlisting>
        
        <para>If you do not like XPath you couls also use another possibility to ignore message contents. The next example uses the special <emphasis>@ignore@</emphasis> placeholder
        directly in the message content:</para>
        
        <programlisting>
  &lt;message&gt;
      &lt;data&gt;
          &lt;![CDATA[
          &lt;RequestMessage&gt;
              &lt;MessageHeader&gt;
                  &lt;CorrelationId&gt;${correlationId}&lt;/CorrelationId&gt;
                  &lt;Timestamp&gt;@ignore@&lt;/Timestamp&gt;
                  &lt;RequestTag&gt;${requestTag}&lt;/RequestTag&gt;
                  &lt;VersionId&gt;2&lt;/VersionId&gt;
              &lt;/MessageHeader&gt;
              &lt;MessageBody&gt;
                  &lt;Customer&gt;
                      &lt;Id&gt;1&lt;/Id&gt;
                  &lt;/Customer&gt;
              &lt;/MessageBody&gt;
          &lt;/RequestMessage&gt;
          ]]&gt;
      &lt;/data&gt;
  &lt;/message&gt;
        </programlisting>
        
        <para>The ignored message elements are automatically skipped when Citrus compares and validates message contents.</para>
    </section>
    
    <section id="message-validation-elements">
        <title>Explicit message element validation</title>
        
        <para>In the previous sections we have seen how to validate whole XML fragments with control message templates. In some cases 
        this approach might be too extensive. Imagine the tester only needs to validate a small subset of message elements. The definition 
        of control templates in combination with several ignore statements is not appropiate in this case. You would rather want
        to use explicit element validation.</para>
        
        <programlisting>
  &lt;message&gt;
      &lt;validate path=&quot;//MessageHeader/RequestTag&quot; 
                   value=&quot;${requestTag}&quot;/&gt;
      &lt;validate path=&quot;//CorrelationId&quot; 
                   value=&quot;${correlationId}&quot;/&gt;
      &lt;validate path=&quot;//MessageBody/Number&quot; 
                   value=&quot;123456789&quot;/&gt;
  &lt;/message&gt;
        </programlisting>  
        
        <para>Instead of comparing the whole message some message elements are validated explicitly over XPath. Citrus evaluates the XPAth expression and 
        and compares its value to the control value. The basic message structure as well as other message elements are not included into validation.</para> 
        
        <note>
            <para>If this type of element validation is choosen neither &lt;data&gt; nor &lt;resource&gt; template definitions are allowed.</para>
        </note>
        
        <tip>
            <para>Citrus offers an alternative dot-notated syntax in order to walk through XML trees. In case you are not 
            familiar with XPath or simply need a very easy way to find your element inside the XML tree you might use this way. Every 
            element hierarchy in the XML tree is represented with a simple dot - for example:</para>
            
            <para><literal>message.body.text</literal></para>
            
            <para>The expression will search the XML tree for the respective &lt;message&gt;&lt;body&gt;&lt;text&gt; element. Attributes 
            are supported too. In case the last element in the dot-notated expression is a XML attribute the framework will automatically 
            find it.</para>
            
            <para>Of course this dot-notated syntax is very simple and might not be applicable for more complex tree walkings. 
            XPath is much more powerful - no doubt. However the dot-notated syntax might help those of you that are not familiar with XPath.
            So the dot-notation is supported wherever XPath expressions might apply.</para>
        </tip>  
    </section>
    
    <section id="message-header-validation">
        <title>Validate the message header</title>
        
        <para>Now that we have validated the message payload in various ways in the previous sections we are also interested in validating the message header. Just
        add the following header validation to your receiving action.</para>
        
        <programlisting>
  &lt;header&gt;
      &lt;element name=&quot;Operation&quot; value=&quot;GetCustomer&quot;/&gt;
      &lt;element name=&quot;RequestTag&quot; value=&quot;${requestTag}&quot;/&gt;
  &lt;/header&gt;    
        </programlisting>
        
        <para>Message headers often occur as name-value pairs. So each header element that we specify in validation has to be present in the received message. In addition to that 
        the header value has to fit the control value. If one header is not found or the value does not fit Citrus will raise errors and the test case will fail.</para>
        
        <note>Sometimes message headers may not apply to the name-value pair pattern. For example SOAP headers can also contain XML fragments. Citrus supports these kind of
        headers too. Please see the SOAP chapter for more details on this.</note>
    </section>
    
    <section id="message-content-extract">
        <title>Saving message content to variables</title>
        
        <para>Imagine you receive a message in your test that contains a generated message id. You have no chance to predict the id
        because it was generated at runtime. In many cases you need to return this id in the respective response message to meet
        the requirements. So Citrus needs to offer a way to save dynamic message content for reuse in later test steps. The solution is simple: 
        we can extract those dynamic values to test variables.</para>
        
        <programlisting>
  &lt;extract&gt;
      &lt;header name=&quot;Operation&quot; variable=&quot;operation&quot;/&gt;
      &lt;message name=&quot;//MessageBody/Customer/Id&quot; 
                  variable=&quot;customerId&quot;/&gt;
  &lt;/extract&gt;
        </programlisting>
        
        <para>As you can see Citrus is able to store both header and message payload content into test variables. It does not matter if you use new test variables 
        or existing ones as target. The extraction will automatically create a new variable in case it does not exist. Once the variable is announced to the test all following test 
        actions can access the variables as usual. So you could reuse the variable value in response messages or other test steps ahead.</para>
    </section>
    
    <section id="message-selector">
        <title>Message selectors</title>
        
        <para>The <emphasis>&lt;selector&gt;</emphasis> element inside the receiving action defines key-value pairs in order to 
        filter the messages being received. The key value pairs apply to the message headers. This means that a receiver will 
        only accept messages that meet the key-value pairs in its header. Using this mechanism you can explicitly listen for 
        messages that belong to your test. This is very helpful to avoid receiving messages from other tests that are still available 
        on the message destination.</para>
        
        <para>Lets say the tested software application keeps sending messages that belong to previous test cases. This could happen in retry 
        situations where the application's error handling automatically tries to solve a communication problem that occurred 
        during previous test cases. As a result the EAI application keeps sending messages that are not valid any more for the currently 
        running test case. The test case might fail because the received message does not apply to the currently tested use case. The messages
        received are simply failing because the message content does not fit the expected one (e.g. correlation-ids, customer informations 
        etc.).</para>
        
        <para>Now we have to find a way to avoid these problems. The test could filter the messages on a destination to only receive messages 
        that apply for the use case that is being tested. The Java Messaging System (JMS) came up with a message header selector that will 
        only accept messages that fit the expected header values.</para>
        
        <para>Let us have a closer look at a message selector inside a receiving action:</para>
        
        <programlisting>
  &lt;selector&gt;
      &lt;element&gt; name="correlationId" value="Lx1x123456789"&lt;/element&gt;
      &lt;element&gt; name="operation" value="getOrders"&lt;/element&gt;
  &lt;/selector&gt;
        </programlisting>
        
        <para>This example shows how selectors work. The selector will only accept messages that meet the correlation id and the operation 
        in the header values. All other messages are ignored. The selector elements are associated to each other using logical AND
        (e.g. where correlationId = 'Lx1x123456789' AND operation = 'getOrders').</para>
        
        <para>You can also define a selector string yourself that gives you more power in constructing the selection logic.</para>
        
        <programlisting>
  &lt;selector&gt;
      &lt;value&gt;
          correlationId = 'Cx1x123456789' OR correlationId = 'Cx1x987654321'
      &lt;/value&gt;
  &lt;/selector&gt;
        </programlisting>
        
        <important>
            <para>In case you want to run tests in parallel you will need to specify message selectors, otherwise the different tests running 
            at the same time will steal messages from each other. In parallel test execution several test cases will listen for messages at 
            the same time.</para>
        </important>
    </section>
    
    <para>At this point you know the two most important test actions in Citrus. Sending and receiving actions will become the main components of your integration tests when dealing 
    with loosely coupled message based components in a SOA. It is very easy to create message flows, meaning a sequence of sending and receiving messages in your test case. 
    You can replicate use cases and test your message exchange with extended message validation possibilities.</para>
  </section>
  
  <section id="groovy-utils">
    <title>Groovy Utils for sending/receiving</title>
    
    <para>Groovy offers some nice and easy to use utilities for working with XML messages. Since version 1.2-SNAPSHOT they can be used 
    in Citrus with the send and receive test actions.</para>
    
    <section id="groovy-markupbuilder">
        <title>Groovy MarkupBuilder (message creation)</title>
        
        <para>With the Groovy MarkupBuilder the tester may define XML messages in a simple way, without using the typical XML syntax. 
        For the example we use the send action from <xref linkend="message-sending"/>, with the difference, that we use script instead of 
        data part and generate the same XML message with the MarkupBuilder:</para>
        
        <programlisting>
  &lt;send with=&quot;getCustomerRequestMessageSender&quot;&gt;
      &lt;message&gt;
          &lt;script&gt;
              xml.RequestMessage{
                  MessageHeader{
                      CorrelationId('${correlationId}')
                      Timestamp('2001-12-17T09:30:47.0Z')
                      RequestTag('_')
                      VersionId('2')
                  }
                  MessageBody{
                      Customer{
                          Id('1')
                      }
                  }
              }
          &lt;/script&gt;
          &lt;element path=&quot;/MessageHeader/RequestTag&quot; 
                      value=&quot;${requestTag}&quot;/&gt;
      &lt;/message&gt;
      &lt;header&gt;
          &lt;element name=&quot;Operation&quot; value=&quot;GetCustomer&quot;/&gt;
          &lt;element name=&quot;RequestTag&quot; value=&quot;${requestTag}&quot;/&gt;
      &lt;/header&gt;
  &lt;/send&gt;
        </programlisting>
        
        <para>To define a XML message with the MarkupBuilder, we use the script-tag inside the message-tag. As you can see from the example, 
        the tester may use the MarkupBuilder with "xml.ROOT-ELEMENT{ CHILD-ELEMENTS }". The XML messages can be created fast and easy, 
        with some simple rules:</para>
        
        <itemizedlist mark="opencircle">
            <listitem><para>The script starts always with "xml", followed by a dot and the name of the root-element of the XML message.</para></listitem>
            <listitem><para>Child-elements may be defined within curly brackets after the root-element(the same applies for child-elements).</para></listitem>
            <listitem><para>Attributes and the content of elements can be defined within round brackets, after the element-name.</para></listitem>
            <listitem><para>Attribute-values and the content have to stand within apostrophes('value').</para></listitem>
        </itemizedlist>
        
        <para>The Groovy MarkupBuilder script may also be used with receive actions:</para>
        
        <programlisting>
  &lt;send with=&quot;helloRequestSender&quot;&gt;
      &lt;message&gt;
          &lt;script-resource file=&quot;file:xmlData/MarkupBuilderSendScript.groovy&quot;/&gt;
      &lt;/message&gt;
  &lt;/send&gt;
  &lt;receive with=&quot;helloResponseReceiver&quot; timeout=&quot;5000&quot;&gt;
      &lt;message&gt;
          &lt;script&gt;
              xml.HelloResponse(xmlns: 'http://www.consol.de/schemas/samples/sayHello.xsd'){
                  MessageId('${messageId}')
                  CorrelationId('${correlationId}')
                  User('HelloService')
                  Text('Hello ${user}')
              }
          &lt;/script&gt;
      &lt;/message&gt;
  &lt;/receive&gt;
        </programlisting>
        
        <para>It is also possible to define the script as external file resource, as you can see from the send action. Namespaces may be 
        defined after the root-element within the round brackets.</para>
        
        <tip>For further information on the use of Groovy's MarkupBuilder see 
        <ulink url="http://groovy.codehaus.org/Creating+XML+using+Groovy%27s+MarkupBuilder">Groovy Website - using MarkupBuilder</ulink></tip> 
    </section>
    
    <section id="groovy-xmlslurper">
        <title>Groovy XmlSlurper (message validation)</title>
        
        <para>With the Groovy XmlSlurper the tester is able to simply validate received XML messages. Therefor he may compare elements of the 
        message(attributes, values, etc.), with expected values and validate this comparisons with "assert":</para>
        
        <programlisting>
  &lt;receive with=&quot;helloResponseReceiver&quot; timeout=&quot;5000&quot;&gt;
      &lt;message>
          &lt;validation-script type=&quot;groovy&quot;&gt;
              assert root.children().size() == 4
              assert root.MessageId.text() == '${messageId}'
              assert root.CorrelationId.text() == '${correlationId}'
              assert root.User.text() == 'HelloService'
              assert root.Text.text() == 'Hello ' + context.getVariable("user")
          &lt;/validation-script&gt;
      &lt;/message&gt;
      &lt;header&gt;
          &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
          &lt;element name=&quot;CorrelationId&quot; value=&quot;${correlationId}&quot;/&gt;
      &lt;/header&gt;
  &lt;/receive&gt;
        </programlisting>
        
        <para>To define Groovy XmlSlurper validation scripts, we use the validation-script-tag inside the message-tag. The validation-script 
        "type" must be set to "groovy". Now the script may be defined with "assert"-statements, comparing values of the received message 
        with expected values. We can get elements of the message with the XmlSlurper, named "root", which represents the root-element of the
        message. Child-elements and attributes may be choosed with a dot, followed by their name or if we need all child-elements, we can 
        use the "children()"-function. The "text()"-function returns the text-value and the "size()"-function, the number of elements in a list</para>
        
        <para>As you can see from the example, we may use variables and the TestContext within the validation script. The script can also be 
        defined as external file resource:</para>
        
        <programlisting>
  &lt;receive with=&quot;helloResponseReceiver&quot; timeout=&quot;5000&quot;&gt;
      &lt;message>
          &lt;validation-script type=&quot;groovy&quot; file=&quot;file:xmlData/validationScript.groovy&quot;/&gt;
      &lt;/message&gt;
      &lt;header&gt;
          &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
          &lt;element name=&quot;CorrelationId&quot; value=&quot;${correlationId}&quot;/&gt;
      &lt;/header&gt;
  &lt;/receive&gt;
        </programlisting>
        
        <note>If validation script is used to validate messages, other validations with data-/resource-/script-/script-resource- or 
        validate-tag are not allowed in the message-tag.</note>
        
        <tip>For further information on the use of Groovy's XmlSlurper see 
        <ulink url="http://groovy.codehaus.org/Reading+XML+using+Groovy%27s+XmlSlurper">Groovy Website - using XmlSlurper</ulink></tip>
    </section>
  </section>
  
</chapter>